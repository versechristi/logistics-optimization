# core/cost_function.py
# -*- coding: utf-8 -*-
"""
Core cost and time evaluation functions for the Multi-Depot, Two-Echelon
Vehicle Routing Problem with Drones and Split Deliveries (MD-2E-VRPSD).

This module provides the objective function calculation, evaluating the
cost, time (makespan), and unmet demand of a given solution structure.
It is designed to work with solutions generated by various algorithms
and specifically adapted for split deliveries and two-echelon operations
within a multi-depot context.

Key features:
- Calculates Stage 1 (Depot to Outlet) costs and time (makespan) per depot.
- Aggregates Stage 1 results across all depots.
- Calculates Stage 2 (Outlet to Customer) costs and time (makespan) for each outlet,
  accounting for vehicle and drone differences and split deliveries by using
  a provided Stage 2 trip generation function.
- Aggregates Stage 2 results across all outlets.
- Determines final unmet demand based on the state of customer demands
  after all Stage 2 trips are considered across all relevant outlets.
- Computes a weighted total cost including penalties for unmet demand.
- Flags solutions as feasible if all demand is met (within a tolerance).
- Includes detailed logging and error handling.

This revised version accepts the Stage 2 trip generation function and the distance
calculation function as arguments to avoid circular imports and ensure flexibility.
It calculates Stage 1 makespan (max over all depots) and Stage 2 makespan (max over all outlets' Stage 2 operations)
and sums them for the total solution makespan, assuming Stage 2 at an outlet starts
only after Stage 1 arrival at that outlet.
"""

import copy
import math
import os
import traceback
import time # For timing evaluation (optional but useful)
import warnings # Use warnings for non-critical issues
import sys # Import the sys module for potential exit or path handling if needed

# --- Safe Imports for Dependencies ---
# Attempt to import necessary core modules safely.
# This block attempts to add the project root to sys.path if necessary,
# making imports of core modules more robust when scripts are run
# from different directories.
try:
    # Assuming this file is in project_root/core
    current_dir = os.path.dirname(os.path.abspath(__file__))
    project_root_cost_func = os.path.dirname(current_dir)
    if project_root_cost_func not in sys.path:
        sys.path.insert(0, project_root_cost_func)
        # print(f"Cost Function: Added project root to sys.path: {project_root_cost_func}") # Optional debug print

    # --- Import necessary components from other core modules ---
    # Import distance calculator - crucial for Stage 1 cost/time calculation
    from core.distance_calculator import haversine

except ImportError as e:
    print(f"CRITICAL ERROR in core.cost_function: Failed during initial import block: {e}")
    traceback.print_exc()
    # Define dummy functions/classes if imports fail to prevent immediate crash
    # but indicate severe error.
    def haversine(coord1, coord2):
        warnings.warn("DUMMY haversine called in cost_function due to import error!")
        # This dummy function returns a simple Manhattan distance for testing purposes
        # It's NOT geographically accurate. Replace with real haversine if possible.
        if not coord1 or not coord2 or len(coord1) != 2 or len(coord2) != 2:
             return float('inf')
        try:
            return abs(coord1[0] - coord2[0]) + abs(coord1[1] - coord2[1]) * 100 # Arbitrary scaling
        except:
            return float('inf')

    warnings.warn("Cost_function will use dummy haversine function due to critical import failure.")

except Exception as e:
    print(f"An unexpected error occurred during cost_function import block: {e}")
    traceback.print_exc()
    # Optionally, raise the error or exit if core dependencies are critical
    # raise e


# Define a small tolerance for floating-point comparisons (e.g., checking if demand is zero)
FLOAT_TOLERANCE = 1e-6

def calculate_total_cost_and_evaluate(
    stage1_routes: dict,
    outlet_to_depot_assignments: dict,
    customer_to_outlet_assignments: dict,
    problem_data: dict,
    vehicle_params: dict,
    drone_params: dict,
    distance_func: callable,
    stage2_trip_generator_func: callable,
    unmet_demand_penalty: float,
    cost_weight: float = 1.0,
    time_weight: float = 0.0
) -> tuple:
    """
    Calculates the total cost, time (makespan), and unmet demand for a given
    multi-depot, two-echelon solution.

    Args:
        stage1_routes (dict): Dictionary where keys are depot indices (int) and
                              values are lists of assigned sales outlet indices (int)
                              in visit order for Stage 1 routes from that depot.
                              Example: {0: [3, 1], 1: [4, 2]}
        outlet_to_depot_assignments (dict): Dictionary mapping sales outlet index (int)
                                           to the index of its assigned logistics center (depot) (int).
                                           Example: {0: 0, 1: 0, 2: 1, 3: 0, 4: 1}
        customer_to_outlet_assignments (dict): Dictionary mapping customer index (int)
                                              to the index of its assigned sales outlet (int).
                                              Example: {0: 3, 1: 3, 2: 1, 3: 4, 4: 2, ...}
        problem_data (dict): Dictionary containing all problem instance data:
                             'locations': {'logistics_centers': [...], 'sales_outlets': [...], 'customers': [...]},
                             'demands': [...] (list of initial customer demands).
        vehicle_params (dict): Dictionary of vehicle parameters (e.g., 'payload', 'cost_per_km', 'speed_kmph').
                               Must include 'cost_per_km' and 'speed_kmph'.
        drone_params (dict): Dictionary of drone parameters (e.g., 'payload', 'max_flight_distance_km', 'cost_per_km', 'speed_kmph').
                             Must include 'cost_per_km' and 'speed_kmph'.
        distance_func (callable): A function that takes two location coordinates (lat, lon)
                                  tuples and returns the distance between them (float).
                                  Signature: distance_func(coord1, coord2) -> float.
        stage2_trip_generator_func (callable): A function that generates Stage 2 trips
                                               from a single outlet.
                                               Signature: stage2_trip_generator_func(outlet_index,
                                               assigned_customer_indices, problem_data,
                                               vehicle_params, drone_params, demands_remaining_global)
                                               -> list of trip dicts. This function *must*
                                               modify `demands_remaining_global`.
        unmet_demand_penalty (float): The penalty cost incurred for each unit of unmet demand.
        cost_weight (float): Weight for the raw cost in the weighted objective function. Defaults to 1.0.
        time_weight (float): Weight for the total time (makespan) in the weighted objective function. Defaults to 0.0.

    Returns:
        tuple: A tuple containing the evaluation results:
               (total_raw_cost, total_time_makespan, final_unmet_demand,
                served_customer_details, evaluation_stage1_error, evaluation_stage2_error,
                stage2_trips_details_aggregated).
               Returns infinite costs/time and error flags if evaluation fails.
    """
    start_time_eval = time.time()
    # print("\n--- Evaluating Solution ---") # Optional debug print

    # --- Initialize Results ---
    evaluation_stage1_error = False
    evaluation_stage2_error = False
    total_raw_cost = float('inf')
    total_time_makespan = float('inf')
    final_unmet_demand = float('inf')
    served_customer_details = {}
    stage2_trips_details_aggregated = {} # Store all generated Stage 2 trips

    # --- Input Validation and Data Extraction ---
    try:
        if not problem_data or 'locations' not in problem_data or 'demands' not in problem_data:
            warnings.warn("Evaluation Error: Invalid 'problem_data' provided.")
            raise ValueError("Invalid problem_data")

        locations = problem_data.get('locations', {})
        initial_demands = problem_data.get('demands', [])

        depot_locations = locations.get('logistics_centers', [])
        outlet_locations = locations.get('sales_outlets', [])
        customer_locations = locations.get('customers', [])

        num_depots = len(depot_locations)
        num_outlets = len(outlet_locations)
        num_customers = len(customer_locations)

        if num_depots == 0 or num_outlets == 0 or num_customers == 0:
             warnings.warn("Evaluation Warning: Problem data contains zero depots, outlets, or customers. Evaluation might be invalid.")
             # Allow continuation, but costs/time might remain infinite

        if not callable(distance_func):
            warnings.warn("Evaluation Error: 'distance_func' is not callable.")
            raise TypeError("Invalid distance_func")

        if not callable(stage2_trip_generator_func):
            warnings.warn("Evaluation Error: 'stage2_trip_generator_func' is not callable.")
            raise TypeError("Invalid stage2_trip_generator_func")

        # Basic parameter checks
        if not isinstance(unmet_demand_penalty, (int, float)) or unmet_demand_penalty < 0:
            warnings.warn(f"Evaluation Warning: Invalid unmet_demand_penalty ({unmet_demand_penalty}). Using 0.0.")
            unmet_demand_penalty = 0.0

        if not isinstance(cost_weight, (int, float)) or not isinstance(time_weight, (int, float)):
             warnings.warn("Evaluation Warning: Cost or time weight is not numeric. Using defaults (1.0, 0.0).")
             cost_weight = 1.0
             time_weight = 0.0

    except Exception as e:
        warnings.warn(f"Error during evaluation setup or validation: {e}")
        traceback.print_exc()
        evaluation_stage1_error = True
        evaluation_stage2_error = True
        # Return current state with error flags and infinite costs
        return (total_raw_cost, total_time_makespan, final_unmet_demand,
                served_customer_details, evaluation_stage1_error, evaluation_stage2_error,
                stage2_trips_details_aggregated)


    # --- Calculate Stage 1 Costs and Time (Depot to Outlet) ---
    total_stage1_cost = 0.0
    stage1_makespans_per_depot = [] # Track makespan for each depot's route

    try:
        if not isinstance(stage1_routes, dict):
            warnings.warn("Evaluation Error: 'stage1_routes' is not a dictionary.")
            raise TypeError("'stage1_routes' must be a dictionary.")

        s1_cost_per_km = vehicle_params.get('cost_per_km', float('inf'))
        s1_speed_kmph = vehicle_params.get('speed_kmph', 0.0)

        if math.isinf(s1_cost_per_km): warnings.warn("Evaluation Warning: Vehicle cost_per_km not specified or infinite.")
        if s1_speed_kmph <= FLOAT_TOLERANCE: warnings.warn("Evaluation Warning: Vehicle speed_kmph is zero or less.")

        for depot_idx, outlet_sequence in stage1_routes.items():
            if not (0 <= depot_idx < num_depots):
                warnings.warn(f"Evaluation Warning: Invalid depot index {depot_idx} found in stage1_routes.")
                evaluation_stage1_error = True
                continue

            if not isinstance(outlet_sequence, list):
                 warnings.warn(f"Evaluation Warning: Stage 1 route for depot {depot_idx} is not a list.")
                 evaluation_stage1_error = True
                 continue

            if not outlet_sequence:
                stage1_makespans_per_depot.append(0.0)
                continue

            depot_coord = depot_locations[depot_idx]
            current_location_coord = depot_coord
            route_cost = 0.0
            route_time = 0.0
            route_has_error = False

            for outlet_idx in outlet_sequence:
                if not (0 <= outlet_idx < num_outlets):
                    warnings.warn(f"Evaluation Warning: Invalid outlet index {outlet_idx} in Stage 1 route for depot {depot_idx}.")
                    evaluation_stage1_error = True
                    route_has_error = True
                    break # Stop processing this route

                outlet_coord = outlet_locations[outlet_idx]
                dist = distance_func(current_location_coord, outlet_coord)

                if math.isinf(dist) or math.isnan(dist):
                     warnings.warn(f"Evaluation Warning: Invalid distance in Stage 1 for depot {depot_idx}, segment to outlet {outlet_idx}.")
                     evaluation_stage1_error = True
                     route_has_error = True
                     break

                route_cost += dist * s1_cost_per_km if not math.isinf(s1_cost_per_km) else 0
                if s1_speed_kmph > FLOAT_TOLERANCE:
                     route_time += dist / s1_speed_kmph
                else:
                     route_time = float('inf') # Time becomes infinite

                current_location_coord = outlet_coord
                if math.isinf(route_time): break # No need to continue if time is infinite

            if route_has_error:
                 total_stage1_cost = float('inf')
                 stage1_makespans_per_depot.append(float('inf'))
                 evaluation_stage1_error = True # Ensure flag is set
                 break # Stop processing depots if one route is critically flawed

            # Add return trip
            if not math.isinf(route_time): # Only if time isn't already infinite
                return_dist = distance_func(current_location_coord, depot_coord)
                if math.isinf(return_dist) or math.isnan(return_dist):
                    warnings.warn(f"Evaluation Warning: Invalid return distance in Stage 1 for depot {depot_idx}.")
                    evaluation_stage1_error = True
                    route_cost = float('inf')
                    route_time = float('inf')
                else:
                    route_cost += return_dist * s1_cost_per_km if not math.isinf(s1_cost_per_km) else 0
                    if s1_speed_kmph > FLOAT_TOLERANCE:
                         route_time += return_dist / s1_speed_kmph
                    else:
                         route_time = float('inf')

            # Accumulate cost only if not already infinite
            if not math.isinf(total_stage1_cost):
                total_stage1_cost += route_cost if not math.isinf(route_cost) else float('inf')
            stage1_makespans_per_depot.append(route_time)

        # If any depot route caused an error, total cost is infinite
        if evaluation_stage1_error:
             total_stage1_cost = float('inf')

    except Exception as e:
        warnings.warn(f"An unexpected error occurred during Stage 1 evaluation: {e}")
        traceback.print_exc()
        evaluation_stage1_error = True
        total_stage1_cost = float('inf')
        stage1_makespans_per_depot = [float('inf')]

    stage1_makespan = max(stage1_makespans_per_depot) if stage1_makespans_per_depot else 0.0


    # --- Calculate Stage 2 Costs and Time (Outlet to Customer) ---
    total_stage2_cost = 0.0
    stage2_makespans_per_outlet = []
    demands_remaining_global = {
        cust_idx: initial_demands[cust_idx] if 0 <= cust_idx < len(initial_demands) and initial_demands[cust_idx] is not None else 0.0
        for cust_idx in range(num_customers)
    }

    try:
        if not isinstance(customer_to_outlet_assignments, dict):
            warnings.warn("Evaluation Error: 'customer_to_outlet_assignments' is not a dictionary.")
            raise TypeError("'customer_to_outlet_assignments' must be a dictionary.")

        outlet_to_customers_assigned_for_s2 = {outlet_idx: [] for outlet_idx in range(num_outlets)}
        for cust_idx, assigned_outlet_idx in customer_to_outlet_assignments.items():
             if not isinstance(cust_idx, int) or not (0 <= cust_idx < num_customers):
                 warnings.warn(f"Evaluation Warning: Invalid customer index {cust_idx} in assignments.")
                 evaluation_stage2_error = True
                 continue
             if assigned_outlet_idx is None or not isinstance(assigned_outlet_idx, int) or not (0 <= assigned_outlet_idx < num_outlets):
                  warnings.warn(f"Evaluation Warning: Customer {cust_idx} assigned to invalid outlet index {assigned_outlet_idx}.")
                  evaluation_stage2_error = True # Unserved customers due to bad assignment is an error state
             else:
                  outlet_to_customers_assigned_for_s2[assigned_outlet_idx].append(cust_idx)

        for outlet_idx in range(num_outlets):
             assigned_customer_indices = outlet_to_customers_assigned_for_s2.get(outlet_idx, [])

             # Call the provided Stage 2 trip generator function
             try:
                  # ** CORRECTED CALL ** Use the correct keyword argument 'outlet_index'
                  outlet_trips = stage2_trip_generator_func(
                      outlet_index=outlet_idx, # Use the correct parameter name
                      assigned_customer_indices=assigned_customer_indices,
                      problem_data=problem_data,
                      vehicle_params=vehicle_params,
                      drone_params=drone_params,
                      demands_remaining_global=demands_remaining_global # Pass the GLOBAL dict
                  )

                  if not isinstance(outlet_trips, list):
                       warnings.warn(f"Evaluation Error: Stage 2 trip generator for outlet {outlet_idx} did not return a list.")
                       evaluation_stage2_error = True
                       outlet_trips = []

                  stage2_trips_details_aggregated[outlet_idx] = outlet_trips

                  outlet_s2_cost = 0.0
                  outlet_s2_times = []
                  outlet_had_error = False

                  for trip in outlet_trips:
                      if not isinstance(trip, dict) or 'cost' not in trip or 'time' not in trip:
                          warnings.warn(f"Evaluation Warning: Invalid trip structure for outlet {outlet_idx}.")
                          evaluation_stage2_error = True
                          outlet_had_error = True; break

                      trip_cost = trip.get('cost', float('inf'))
                      trip_time = trip.get('time', float('inf'))

                      if math.isinf(trip_cost) or math.isnan(trip_cost): trip_cost = float('inf')
                      if math.isinf(trip_time) or math.isnan(trip_time): trip_time = float('inf')

                      total_stage2_cost += trip_cost
                      outlet_s2_cost += trip_cost
                      outlet_s2_times.append(trip_time)

                      if math.isinf(total_stage2_cost): break # Stop accumulating if cost becomes infinite

                  if outlet_had_error or math.isinf(total_stage2_cost):
                       stage2_makespans_per_outlet.append(float('inf'))
                  else:
                       outlet_s2_makespan = max(outlet_s2_times) if outlet_s2_times else 0.0
                       stage2_makespans_per_outlet.append(outlet_s2_makespan)

             except Exception as e:
                  warnings.warn(f"An unexpected error occurred calling Stage 2 trip generator for outlet {outlet_idx}: {e}")
                  traceback.print_exc()
                  evaluation_stage2_error = True
                  stage2_makespans_per_outlet.append(float('inf')) # Mark makespan as infinite for this outlet

    except Exception as e:
        warnings.warn(f"An unexpected error occurred during Stage 2 evaluation setup: {e}")
        traceback.print_exc()
        evaluation_stage2_error = True
        total_stage2_cost = float('inf')
        stage2_makespans_per_outlet = [float('inf')]
        stage2_trips_details_aggregated = {}

    stage2_makespan = max(stage2_makespans_per_outlet) if stage2_makespans_per_outlet else 0.0
    if evaluation_stage2_error: total_stage2_cost = float('inf')


    # --- Calculate Total Makespan ---
    if math.isinf(stage1_makespan) or math.isinf(stage2_makespan):
        total_time_makespan = float('inf')
    else:
        total_time_makespan = stage1_makespan + stage2_makespan


    # --- Calculate Final Unmet Demand and Served Details ---
    final_unmet_demand = float('inf') # Default to infinite if calculation fails
    if isinstance(demands_remaining_global, dict):
        try:
            # Ensure all customers are accounted for, even if not in remaining dict initially (shouldn't happen with init)
            current_unmet = 0.0
            for cust_idx in range(num_customers):
                 initial_d = initial_demands[cust_idx] if 0 <= cust_idx < len(initial_demands) and initial_demands[cust_idx] is not None else 0.0
                 remaining_d = demands_remaining_global.get(cust_idx, initial_d) # Default to initial if missing

                 # Clamp remaining demand to be non-negative and not exceed initial
                 remaining_d = max(0.0, min(remaining_d, initial_d))
                 current_unmet += remaining_d

                 # Populate served details
                 served_d = initial_d - remaining_d
                 status = "Fully Served"
                 if remaining_d > FLOAT_TOLERANCE:
                      if served_d > FLOAT_TOLERANCE: status = "Partially Served"
                      else: status = "Not Served"

                 served_customer_details[cust_idx] = {
                     'initial': initial_d,
                     'satisfied': served_d,
                     'remaining': remaining_d,
                     'status': status
                 }
            final_unmet_demand = current_unmet

        except Exception as e:
             warnings.warn(f"Error calculating final unmet demand or served details: {e}")
             traceback.print_exc()
             final_unmet_demand = float('inf') # Set to infinite on error
             served_customer_details = {} # Clear potentially partial details
             evaluation_stage2_error = True # Flag error if this calculation failed
    else:
         warnings.warn("Evaluation Error: Invalid demands_remaining_global after Stage 2.")
         evaluation_stage2_error = True


    # --- Calculate Total Raw Cost ---
    if math.isinf(total_stage1_cost) or math.isnan(total_stage1_cost) or math.isinf(total_stage2_cost) or math.isnan(total_stage2_cost):
        total_raw_cost = float('inf')
    else:
        total_raw_cost = total_stage1_cost + total_stage2_cost

    # Ensure infinite cost if evaluation errors occurred
    if evaluation_stage1_error or evaluation_stage2_error:
         total_raw_cost = float('inf')
         total_time_makespan = float('inf')
         # Unmet demand might be calculable, but solution is effectively invalid

    end_time_eval = time.time()
    # print(f"Evaluation completed in {end_time_eval - start_time_eval:.4f} seconds.") # Optional debug print

    # --- Final Return ---
    return (total_raw_cost, total_time_makespan, final_unmet_demand,
            served_customer_details, evaluation_stage1_error, evaluation_stage2_error,
            stage2_trips_details_aggregated)


# --- Helper for formatting float values (copied from report_generator or define centrally) ---
# Needed for printing final evaluation results or within this module if needed
def format_float(value, precision=4):
    """
    Safely formats a numerical value to a specified precision string.
    Handles None, NaN, Infinity, and non-numeric types gracefully.
    Copied here for standalone testing capability, but a central definition is preferred.
    """
    if isinstance(value, (int, float)):
        if math.isnan(value):
            return "NaN"
        if value == float('inf'):
            return "Infinity"
        if value == float('-inf'):
            return "-Infinity"
        try:
            # Use f-string formatting with specified precision
            return f"{value:.{precision}f}"
        except Exception: # Catch potential formatting errors with unusual floats
            return str(value) # Fallback
    elif value is None:
        return "N/A" # Not Available
    else:
        # Attempt to convert other types to string
        try:
            return str(value)
        except Exception:
            return "Invalid Value" # Cannot convert to string


# --- Dummy Stage 2 Trip Generator for Standalone Testing ---
# This is a minimal dummy implementation just to allow the cost function to run
# without depending on the actual problem_utils.create_heuristic_trips_split_delivery
# for standalone testing. The actual cost function call *must* use the real one.
# It needs access to haversine for dummy cost/time calculation, so assuming haversine is imported.
def dummy_stage2_trip_generator(outlet_index, assigned_customer_indices, problem_data, vehicle_params, drone_params, demands_remaining_global):
     """DUMMY Stage 2 generator for cost_function standalone testing."""
     # print(f"DUMMY Stage 2 generator called for outlet {outlet_index}.") # Optional debug print
     # This dummy generator simply marks a fraction of demand as met.
     # It does NOT simulate realistic trips, costs, or times.
     # It *must* modify demands_remaining_global as required by the real function.

     generated_trips = []
     outlet_s2_cost = 0.0
     outlet_s2_time = 0.0
     FLOAT_TOLERANCE_DUMMY = 1e-6 # Local tolerance

     for cust_idx in assigned_customer_indices:
         if cust_idx in demands_remaining_global and demands_remaining_global[cust_idx] > FLOAT_TOLERANCE_DUMMY:
             initial_d = problem_data.get('demands', [])[cust_idx] if cust_idx < len(problem_data.get('demands', [])) and problem_data.get('demands', [])[cust_idx] is not None else 0.0
             remaining_d_before = demands_remaining_global[cust_idx]

             # Simulate serving half of the remaining demand for this customer
             served_amount = remaining_d_before * 0.5
             demands_remaining_global[cust_idx] -= served_amount
             if demands_remaining_global[cust_idx] < FLOAT_TOLERANCE_DUMMY: # Clamp to zero with tolerance
                  demands_remaining_global[cust_idx] = 0.0

             # Create a dummy trip entry
             if served_amount > FLOAT_TOLERANCE_DUMMY:
                  # Dummy cost/time based on distance (assuming a round trip with some dummy vehicle/drone)
                  outlet_locs = problem_data.get('locations', {}).get('sales_outlets', [])
                  cust_locs = problem_data.get('locations', {}).get('customers', [])
                  dummy_cost = 10.0 # Default dummy cost
                  dummy_time = 0.1 # Default dummy time
                  if 0 <= outlet_index < len(outlet_locs) and 0 <= cust_idx < len(cust_locs):
                       # Use the real haversine function (assuming it's imported or a dummy exists)
                       dist_func = haversine
                       dummy_dist = dist_func(outlet_locs[outlet_index], cust_locs[cust_idx]) * 2 # Round trip
                       if not math.isinf(dummy_dist):
                            # Use vehicle params for dummy calculation
                            cost_km = vehicle_params.get('cost_per_km', 1.0)
                            speed_kmh = vehicle_params.get('speed_kmph', 50.0)
                            dummy_cost = dummy_dist * cost_km
                            dummy_time = dummy_dist / speed_kmh if speed_kmh > 1e-6 else float('inf')


                  generated_trips.append({
                      'type': 'vehicle', # Dummy type
                      'route': [cust_idx],
                      'load': served_amount,
                      'cost': dummy_cost,
                      'time': dummy_time
                  })
                  outlet_s2_cost += dummy_cost
                  outlet_s2_time = max(outlet_s2_time, dummy_time) # Dummy makespan for this outlet


     return generated_trips


# --- Optional Main Execution Block for Standalone Testing ---
if __name__ == '__main__':
    """
    Standalone execution block for testing the cost_function.
    Requires dummy problem data and Stage 1 routes/assignments.
    Uses a DUMMY Stage 2 generator and the real haversine (if imported).
    """
    print("Running core/cost_function.py in standalone test mode.")

    # --- Create Dummy Evaluation Data ---
    try:
        print("\n--- Creating Dummy Evaluation Data ---")
        # Needs to match the structure expected by calculate_total_cost_and_evaluate
        dummy_locations = {
            'logistics_centers': [
                (34.0, -118.0), # Depot 0
                (34.1, -118.2), # Depot 1
            ],
            'sales_outlets': [
                (34.05, -118.1), # Outlet 0 - assigned to Depot 0
                (34.02, -118.05), # Outlet 1 - assigned to Depot 0
                (34.15, -118.3), # Outlet 2 - assigned to Depot 1
                (33.95, -118.15), # Outlet 3 - assigned to Depot 0
            ],
            'customers': [
                (34.06, -118.11), # Customer 0 - assigned to Outlet 0
                (34.05, -118.09), # Customer 1 - assigned to Outlet 0
                (34.00, -118.06), # Customer 2 - assigned to Outlet 1
                (34.16, -118.31), # Customer 3 - assigned to Outlet 2
                (34.14, -118.28), # Customer 4 - assigned to Outlet 2
                (33.96, -118.16), # Customer 5 - assigned to Outlet 3
            ]
        }
        dummy_demands = [10.0, 15.0, 8.0, 20.0, 12.0, 5.0] # len = 6

        dummy_problem_data = {
            'locations': dummy_locations,
            'demands': dummy_demands
        }

        # Dummy Vehicle and Drone Params
        dummy_vehicle_params = {'payload': 200.0, 'cost_per_km': 1.5, 'speed_kmph': 60.0}
        dummy_drone_params = {'payload': 30.0, 'max_flight_distance_km': 15.0, 'cost_per_km': 0.8, 'speed_kmph': 100.0}
        dummy_unmet_penalty = 500.0
        dummy_cost_weight = 1.0
        dummy_time_weight = 0.1

        # Dummy Assignments (matching the logic in problem_utils.create_initial_solution_mdsd)
        dummy_outlet_to_depot_assignments = {0: 0, 1: 0, 2: 1, 3: 0}
        dummy_customer_to_outlet_assignments = {0: 0, 1: 0, 2: 1, 3: 2, 4: 2, 5: 3} # C0,C1->O0; C2->O1; C3,C4->O2; C5->O3

        # Dummy Stage 1 Routes (example Nearest Neighbor result)
        dummy_stage1_routes = {
            0: [0, 3, 1], # Depot 0 visits Outlet 0, then 3, then 1
            1: [2]       # Depot 1 visits Outlet 2
        }

        print("Dummy data, assignments, and Stage 1 routes created.")

    except Exception as e:
        print(f"Error creating dummy evaluation data: {e}")
        traceback.print_exc()
        sys.exit(1)


    # --- Test calculate_total_cost_and_evaluate ---
    print("\n--- Testing calculate_total_cost_and_evaluate ---")
    try:
        # Use the actual haversine (if available) and the DUMMY Stage 2 generator
        eval_results = calculate_total_cost_and_evaluate(
            stage1_routes=dummy_stage1_routes,
            outlet_to_depot_assignments=dummy_outlet_to_depot_assignments,
            customer_to_outlet_assignments=dummy_customer_to_outlet_assignments,
            problem_data=dummy_problem_data,
            vehicle_params=dummy_vehicle_params,
            drone_params=dummy_drone_params,
            distance_func=haversine, # Use the imported or dummy haversine
            stage2_trip_generator_func=dummy_stage2_trip_generator, # Use the DUMMY Stage 2 generator for this test
            unmet_demand_penalty=dummy_unmet_penalty,
            cost_weight=dummy_cost_weight,
            time_weight=dummy_time_weight
        )

        (total_raw_cost, total_time_makespan, final_unmet_demand,
         served_customer_details, evaluation_stage1_error, evaluation_stage2_error,
         stage2_trips_details_aggregated) = eval_results


        print("\nEvaluation Results:")
        print(f"  Total Raw Cost: {format_float(total_raw_cost, 2)}")
        print(f"  Total Time (Makespan): {format_float(total_time_makespan, 2)}")
        print(f"  Final Unmet Demand: {format_float(final_unmet_demand, 2)}")
        # Calculate weighted cost based on returned values for verification
        # Note: This calculation should ideally match the one done inside SolutionCandidate.evaluate
        # Handle potential infinities safely
        safe_raw_cost = total_raw_cost if not math.isinf(total_raw_cost) else float('inf')
        safe_time = total_time_makespan if not math.isinf(total_time_makespan) else float('inf')
        safe_unmet = final_unmet_demand if not math.isinf(final_unmet_demand) else float('inf')
        calculated_weighted_cost = (dummy_cost_weight * safe_raw_cost +
                                    dummy_time_weight * safe_time +
                                    dummy_unmet_penalty * safe_unmet)
        print(f"  Weighted Cost (Objective): {format_float(calculated_weighted_cost, 4)}")
        print(f"  Evaluation Stage 1 Error: {evaluation_stage1_error}")
        print(f"  Evaluation Stage 2 Error: {evaluation_stage2_error}")
        # Determine feasibility based on returned unmet demand and error flags
        is_feasible_result = (not evaluation_stage1_error and
                              not evaluation_stage2_error and
                              final_unmet_demand is not None and
                              not math.isinf(final_unmet_demand) and
                              not math.isnan(final_unmet_demand) and
                              final_unmet_demand < FLOAT_TOLERANCE)
        print(f"  Is Feasible: {is_feasible_result}")

        print("\nServed Customer Details Summary (first few):")
        if isinstance(served_customer_details, dict):
            sorted_customer_indices = sorted(served_customer_details.keys())
            for count, cust_idx in enumerate(sorted_customer_indices):
                 if count >= 5: # Print only first 5 customers
                     print("  ...")
                     break
                 details = served_customer_details[cust_idx]
                 print(f"  Customer {cust_idx}: Initial={format_float(details['initial'],2)}, Satisfied={format_float(details['satisfied'],2)}, Remaining={format_float(details['remaining'],2)}, Status={details['status']}")
        else:
             print("  Served customer details not available or invalid.")


        print("\nStage 2 Trips Generated by Outlet (aggregated):")
        if isinstance(stage2_trips_details_aggregated, dict):
             sorted_outlet_indices = sorted(stage2_trips_details_aggregated.keys())
             for outlet_idx in sorted_outlet_indices:
                  trips = stage2_trips_details_aggregated[outlet_idx]
                  if isinstance(trips, list):
                       print(f"  Outlet {outlet_idx}: {len(trips)} trips generated.")
                  else:
                       print(f"  Outlet {outlet_idx}: Trip data not available or invalid type.")
        else:
             print("  Stage 2 aggregated trip details not available or invalid.")


    except Exception as e:
        print(f"An unexpected error occurred during calculate_total_cost_and_evaluate test: {e}")
        traceback.print_exc()

    print("\nStandalone test finished.")